;h+
; (c) 2017 Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.
;h-

;+
; :Description:
;    Simple routine for masking statistics generated with getFXRasterStats. This tool is
;    useful for excluding pixels based on spectral characteristics or size.
;
;
;
; :Keywords:
;    INPUT_STATS: in, requried, type=orderedhash
;      Specifyt he statistics generated by getFXRasterStats that you want to mask
;    MEAN_MIN: in, optional, type=number
;      Specify the minimum allowed pixel value for the segment means. If stats contain
;      more than one band, then this mask is applied to each band and, if any band fails, 
;      then all are masked.
;    MEAN_MAX: in, optional, type=number
;      Specify the maximum allowed pixel value for the segment means. If stats contain
;      more than one band, then this mask is applied to each band and, if any band fails, 
;      then all are masked.
;    SIZE_MIN: in, optional, type=number, units=meters^2
;      Specify the minimum allowed size. If the source has a spatial reference, then the
;      units are in meters^2, othersie they are the number of pixels.
;    SIZE_MAX: in, optional, type=number
;      Specify the maximum allowed size. If the source has a spatial reference, then the
;      units are in meters^2, othersie they are the number of pixels.
;    OUTPUT_STATS:out, requried, type=orderedhash
;      The output stats returned by the procedure
;
; :Author: Zachary Norman - GitHub:znorman-harris
;-
pro maskFxRasterStats,$
  INPUT_STATS = input_stats,$
  MEAN_MIN = mean_min,$
  MEAN_MAX = mean_max,$
  SIZE_MIN = size_min,$
  SIZE_MAX = size_max,$
  OUTPUT_STATS = output_stats
  compile_opt idl2

  ;get current ENVI session
  e = envi(/CURRENT)

  if ~isa(input_stats, 'hash') then begin
    message, 'INPUT_STATS is not a valid hash object. Has it been specified?'
  endif

  ;get the data from our input_stats dictionary
  totals = input_stats['TOTALS']
  counts = input_stats['COUNTS']
  mins = input_stats['MINS']
  maxs = input_stats['MAXS']
  means = input_stats['MEANS']
  validData = input_stats['VALID_DATA']
  statsRaster = input_stats['RASTER']
  metadata = statsRaster.METADATA
  bandNames = metadata['band names']

  ;get the number of bands for our input_stats raster
  nBands = n_elements(bandNames)

  ;apply our thresholds to the valid data
  ;check min/max size
  ;check if we specified our minimum size
  if keyword_set(size_min) then begin
    ;check for spatialref
    if (statsRaster.SPATIALREF ne !NULL) then begin
      minSize = ceil(size_min/((pixel_size(statsRaster))[0]^2))
    endif else begin
      minSize = size_min
    endelse
    
    ;turn off small size
    idxOff = where(counts lt minSize, countOff)
    if (countOff gt 0) then begin
      validData[idxOff] = 0
    endif
  endif

  ;check if we specified our minimum size
  if keyword_set(size_max) then begin
    ;check for spatialref
    if (statsRaster.SPATIALREF ne !NULL) then begin
      maxSize = ceil(size_max/((pixel_size(statsRaster))[0]^2))
    endif else begin
      maxSize = size_max
    endelse
    
    ;turn off large size
    idxOff = where(counts gt maxSize, countOff)
    if (countOff gt 0) then begin
      validData[idxOff] = 0
    endif
  endif

  ;check for minimum value (looks at each band, turns off if any match filter)
  if keyword_set(mean_min) then begin
    if (nBands gt 1) then begin
      flags = total(means lt mean_min, 2, /INTEGER)
    endif else begin
      flags = means lt mean_min
    endelse
    
    idxOff = where(flags, countOff)
    if (countOff gt 0) then begin
      validData[idxOff] = 0
    endif
  endif
  
  ;check for minimum value (looks at each band, turns off if any match filter)
  if keyword_set(mean_max) then begin
    if (nBands gt 1) then begin
      flags = total(means gt mean_max, 2, /INTEGER)
    endif else begin
      flags = means gt mean_max
    endelse

    idxOff = where(flags, countOff)
    if (countOff gt 0) then begin
      validData[idxOff] = 0
    endif
  endif

  ;make new output raster
  output_stats = orderedhash(input_stats.keys(), input_stats.values())
  output_stats['VALID_DATA'] = validData
end