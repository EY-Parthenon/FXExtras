;h+
; (c) 2017 Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.
;h-

;+
; :Description:
;    Simple procedure that will extract statistics from a segment image
;    generated by ENVI's feature extraction tools.
;
;
;
; :Keywords:
;    BUFFER: in, optional, type=long
;      Specify the buffer to be used around each tile while extracting data from
;      `STATS_RASTER`. An example where this would be useful is if you have a 
;      pixelwise band math raster of a sobel filter: a buffer of one will remove
;      the tile artifacts from processing.
;    FX_RASTER: in, requried, type=EVNIRaster
;      Specify the segment raster generated by feature extraction.
;    STATS_RASTER: in, required, type=EVNIRaster
;      Specifyt he raster that you want to extract statistics for. Rasters must have the
;      same dimensions. If not, use image intersection or the virtualRasterIntersection 
;      routine that is provided.
;    OUTPUT_STATS: out, required, type=orderedhash
;      An orderedhash that contains all of the extracted statistics.
;
; :Author: Zachary Norman - Github: znorman-harris
;-
pro getFxRasterStats,$
  BUFFER = buffer,$
  FX_RASTER = fx_raster,$
  STATS_RASTER = stats_raster,$
  OUTPUT_STATS = output_stats
  compile_opt idl2

  ;get current ENVI session
  e = envi(/CURRENT)

  ;make sure our inputs are valid
  if (fx_raster.NBANDS ne 1) then begin
    message, 'FX_RASTER does not have one band, required!'
  endif
  if ~(stats_raster.NBANDS ge 1) then begin
    message, 'STATS_RASTER does not have one or more bands, required!'
  endif
  
  ;make sure the dimensions are correct
  dims1 = [fx_raster.NCOLUMNS, fx_raster.NROWS]
  dims2 = [stats_raster.NCOLUMNS, stats_raster.NROWS]
  
  if ~array_equal(dims1, dims2) then begin
    message, 'FX_RASTER adn STATS_RASTER do not have the same spatial dimensions. requried!'
  endif
  
  ;check min/max size
  ;check if we specified our minimum size
  if keyword_set(min_size) then begin
    if (fx_raster.SPATIALREF ne !NULL) then begin
      minSize = ceil(min_size/((pixel_size(fx_raster))[0]^2))
    endif else begin
      minSize = min_size
    endelse
  endif else begin
    minSize = 0
  endelse
  
  ;check if we specified our minimum size
  if keyword_set(max_size) then begin
    if (fx_raster.SPATIALREF ne !NULL) then begin
      maxSize = ceil(max_size/((pixel_size(fx_raster))[0]^2))
    endif else begin
      maxSize = max_size
    endelse
  endif else begin
    maxSize = 0
  endelse
  
  ;check buffer
  if (buffer eq !NULL) then begin
    buffer = 0
  endif
  
  ;get initial stats
  stats = ENVIRasterStatistics(fx_raster)
  
  ;get the number of bands for our stats raster
  nBands = stats_raster.NBANDS
  dims = [stats_raster.NCOLUMNS, stats_raster.NROWS]
  bandPixels = ulong64(dims[0])*dims[1]
  
  ;preallocate arrays
  totals = 0*dblarr(stats.MAX, nBands)
  validData = 0b*bytarr(stats.MAX) + 1b
  mins = make_array(stats.MAX, nBands, TYPE = 5, VALUE = 1e308)
  maxs = make_array(stats.MAX, nBands, TYPE = 5, VALUE = -1e308)
  means = make_array(stats.MAX, nBands, TYPE = 5)
  counts = ulon64arr(stats.MAX)

  ;make our tiles
  createBetterTileIterator,$
    TILE_BUFFER = buffer,$    
    INPUT_RASTER = fx_raster,$
    OUTPUT_TILE_SUB_RECTS = tile_sub_rects,$
    OUTPUT_SUB_RECTS = sub_rects

  ;array of pointers for the bands
  bPtrs = ptrarr(nbands)

  ;loop over each tile
  foreach sub, sub_rects, z do begin
    ;get the label sub rect
    fxDatSub = fx_raster.getData(PIXEL_STATE = ps1, SUB_RECT = sub)

    ;get the raster data
    rasterDat = stats_raster.getData(PIXEL_STATE = ps2, SUB_RECT = sub, INTERLEAVE = 'BSQ')
    
    ;check if we have a buffer and need to subset our data
    if (buffer gt 0) then begin
      ;get the extent of our tile that we need to process
      tileSub = tile_sub_rects[z]

      ;subst our datasets      
      fxDatSub = fxDatSub[tileSub[0]:tileSub[2], tileSub[1]:tileSub[3],*]
      ps1 = ps1[tileSub[0]:tileSub[2], tileSub[1]:tileSub[3],*]
      rasterDat = rasterDat[tileSub[0]:tileSub[2], tileSub[1]:tileSub[3],*]
      ps2 = ps2[tileSub[0]:tileSub[2], tileSub[1]:tileSub[3],*]
    endif
    
    ;save each band of our dataset
    for j=0, nBands-1 do bPtrs[j] = ptr_new(rasterDat[*,*,j])
    
    ;correct the second pixel state if needed to be 1D array that ignores all pixels if single one is turned off
    if (nBands gt 1) then begin
      ps2 = total(ps2, 3, /INTEGER)
    endif
    
    ;skip if no valid pixels
    if (fxDatSub.max() lt 1) then continue
    
    ;calculate the histogram
    h = histogram(fxDatSub, MIN = 1, REVERSE_INDICES = r, LOCATIONS = vals)
    
    ;zero values
    vals--
    
    ;update our counts
    counts[vals] += h
    
    ;find values we have counts for
    idxCount = where(h, countOk)
    
    ;loop over each segment if counts are present
    if (countOk gt 0) then begin
      ;clean up our land mask
      foreach i, idxCount do begin
        ;skip if the indices are invalid for our pixel (zero from histogram?)
        if (R[i] eq R[i+1]) then continue
        
        ;get the indices
        idxSeg = R[R[i] : R[i+1]-1]

        ;make sure that we have have a valid pixel state in the FX raster AND the raster we are getting data from
        if (max(ps1[idxSeg]) gt 0) OR (max(ps2[idxSeg]) gt 0) then begin
          validData[vals[i]] = 0b
          continue
        endif else begin
          ;valid data, so set our flag to 1 in case it was turned off for another tile
          validData[vals[i]] = 1b
        endelse

        ;get the OK parts of our data
        idxOk = where(~ps2[idxSeg], countOk)

        ;loop over each band
        for j=0, nBands-1 do begin
          ;subset to our FX segment
          rasterDatSeg = (*bPtrs[j])[idxSeg[idxOk]]
          
          ;update our stats
          totals[vals[i], j] += total(rasterDatSeg, /NAN)
          mins[vals[i], j] <= min(rasterDatSeg, /NAN)
          maxs[vals[i], j] >= max(rasterDatSeg, /NAN)
        endfor
      endforeach
    endif
  endforeach

  ;get the segments that had valid data.
  idxOk = where(counts, countOk)
  if (countOk gt 0) then begin
    ;calculate the means
    for j=0, nBands-1 do means[*,j] = totals[*,j]/counts
  endif
  
  ;build a dictionary to hold the information
  output_stats = orderedhash()
  output_stats['MEANS']      = means
  output_stats['TOTALS']     = temporary(reform(totals))
  output_stats['COUNTS']     = temporary(counts)
  output_stats['MINS']       = temporary(mins)
  output_stats['MAXS']       = temporary(maxs)
  output_stats['VALID_DATA'] = temporary(validData)
  output_stats['RASTER'] = stats_raster
end